// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const addMessage = `-- name: AddMessage :exec
insert into messages (id, "from", "to", body, status, "timestamp")
values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type AddMessageParams struct {
	ID        uuid.UUID
	From      string
	To        string
	Body      string
	Status    string
	Timestamp int64
}

func (q *Queries) AddMessage(ctx context.Context, arg AddMessageParams) error {
	_, err := q.db.ExecContext(ctx, addMessage,
		arg.ID,
		arg.From,
		arg.To,
		arg.Body,
		arg.Status,
		arg.Timestamp,
	)
	return err
}

const addPendingMessage = `-- name: AddPendingMessage :exec
insert into pending_messages (id, "from", "to", body, "timestamp")
values (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type AddPendingMessageParams struct {
	ID        uuid.UUID
	From      string
	To        string
	Body      string
	Timestamp int64
}

func (q *Queries) AddPendingMessage(ctx context.Context, arg AddPendingMessageParams) error {
	_, err := q.db.ExecContext(ctx, addPendingMessage,
		arg.ID,
		arg.From,
		arg.To,
		arg.Body,
		arg.Timestamp,
	)
	return err
}

const changeStatus = `-- name: ChangeStatus :exec
update messages set status = $2 where id = $1
`

type ChangeStatusParams struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) ChangeStatus(ctx context.Context, arg ChangeStatusParams) error {
	_, err := q.db.ExecContext(ctx, changeStatus, arg.ID, arg.Status)
	return err
}

const getChats = `-- name: GetChats :many
select doubled_chats."user"
from (
         select case
                    when "from" = $1 then "to"
                    else "from"
                    end
                                 as "user",
                max("timestamp") as "timestamp"
         from messages
         where "from" = $1 
            or "to" = $1 
         group by "from", "to"
     ) as doubled_chats
group by doubled_chats."user"
order by max("timestamp") desc
limit 100 offset $2
`

type GetChatsParams struct {
	From   string
	Offset int32
}

func (q *Queries) GetChats(ctx context.Context, arg GetChatsParams) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getChats, arg.From, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var user interface{}
		if err := rows.Scan(&user); err != nil {
			return nil, err
		}
		items = append(items, user)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatsFrom = `-- name: GetChatsFrom :many
select "to" as "user"
from messages
where "from" = $1
group by "to"
order by max("timestamp") desc
limit 100 offset $2
`

type GetChatsFromParams struct {
	From   string
	Offset int32
}

func (q *Queries) GetChatsFrom(ctx context.Context, arg GetChatsFromParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getChatsFrom, arg.From, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user string
		if err := rows.Scan(&user); err != nil {
			return nil, err
		}
		items = append(items, user)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatsTo = `-- name: GetChatsTo :many
select "from" as "user"
from messages
where "to" = $1
group by "from"
order by max("timestamp") desc
limit 100 offset $2
`

type GetChatsToParams struct {
	To     string
	Offset int32
}

func (q *Queries) GetChatsTo(ctx context.Context, arg GetChatsToParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getChatsTo, arg.To, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user string
		if err := rows.Scan(&user); err != nil {
			return nil, err
		}
		items = append(items, user)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessage = `-- name: GetMessage :one
select id, "from", "to", body, unread, status, timestamp
from messages
where id = $1
limit 1
`

func (q *Queries) GetMessage(ctx context.Context, id uuid.UUID) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.From,
		&i.To,
		&i.Body,
		&i.Unread,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getMessages = `-- name: GetMessages :many
select messages.id, messages."from", messages."to", messages.body, messages.unread, messages.status, messages.timestamp
from messages
         left join statuses on messages.status = statuses.name
where ("from" = $1 or "to" = $1)
  and code = 1
limit 1000 offset $2
`

type GetMessagesParams struct {
	From   string
	Offset int32
}

func (q *Queries) GetMessages(ctx context.Context, arg GetMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMessages, arg.From, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.From,
			&i.To,
			&i.Body,
			&i.Unread,
			&i.Status,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesWith = `-- name: GetMessagesWith :many
select messages.id, messages."from", messages."to", messages.body, messages.unread, messages.status, messages.timestamp
from messages
         left join statuses on messages.status = statuses.name
where ("from" = $1 and "to" = $2)
   or ("from" = $2 and "to" = $1)
    and code = 1
limit 1000 offset $3
`

type GetMessagesWithParams struct {
	From   string
	To     string
	Offset int32
}

func (q *Queries) GetMessagesWith(ctx context.Context, arg GetMessagesWithParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesWith, arg.From, arg.To, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.From,
			&i.To,
			&i.Body,
			&i.Unread,
			&i.Status,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingMessages = `-- name: GetPendingMessages :many
select id, "from", "to", body, timestamp, proceed from pending_messages where proceed = false
limit 1000 offset $1
`

func (q *Queries) GetPendingMessages(ctx context.Context, offset int32) ([]PendingMessage, error) {
	rows, err := q.db.QueryContext(ctx, getPendingMessages, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PendingMessage
	for rows.Next() {
		var i PendingMessage
		if err := rows.Scan(
			&i.ID,
			&i.From,
			&i.To,
			&i.Body,
			&i.Timestamp,
			&i.Proceed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatuses = `-- name: GetStatuses :many
select id, name, code, description from statuses
`

func (q *Queries) GetStatuses(ctx context.Context) ([]Status, error) {
	rows, err := q.db.QueryContext(ctx, getStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Status
	for rows.Next() {
		var i Status
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const proceedMessage = `-- name: ProceedMessage :exec
insert into messages (id, "from", "to", body, unread, status, timestamp)
select id, "from", "to", body, true, 'PROCESS', timestamp
from pending_messages
where pending_messages.id = $1
  and not proceed
`

func (q *Queries) ProceedMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, proceedMessage, id)
	return err
}

const readMessageById = `-- name: ReadMessageById :exec
update messages
set unread = false
where id = $1
`

func (q *Queries) ReadMessageById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, readMessageById, id)
	return err
}

const readMessagesFromTo = `-- name: ReadMessagesFromTo :exec
update messages
set unread = false
where "from" = $1
  and "to" = $2
`

type ReadMessagesFromToParams struct {
	From string
	To   string
}

func (q *Queries) ReadMessagesFromTo(ctx context.Context, arg ReadMessagesFromToParams) error {
	_, err := q.db.ExecContext(ctx, readMessagesFromTo, arg.From, arg.To)
	return err
}
